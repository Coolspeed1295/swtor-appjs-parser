var fs = require('fs')
  , util = require('util')
  , events = require('events')
  ;
  
function CombatLogParser(log_dir){
  var self = this;
  this.log_dir = log_dir;
  this.watcher = null;
  this.read_stream = null;
  this.chunk_buffer = "";
  this.last_logfile = null;
  this.last_logfile_readpt = 0;
}

util.inherits(CombatLogParser, events.EventEmitter);

CombatLogParser.prototype.start = function (){
  if (this.watcher !== null){
    this.emit('error', new Error('Watcher is already running'));
  }
  else {
    var self = this;
    this.watcher = fs.watch(this.log_dir, {persistent: true}, function (event, filename){
      if (event === "rename"){
        self.emit('debug', "I don't know what to do with rename events: " + filename);
      }
      else if (event === "change"){
        self.emit('debug', "change event for: " + filename);
        if (filename !== self.last_logfile){
          self.last_logfile = filename;
          self.last_logfile_readpt = 0;
        }
        
        self.readFile();
      }
      else {
        self.emit('error', new Error("Unknown event type emitted from the directory watcher"));
      }
    });
  }
  
  this.on('parse', function (event){
    self.emit('data', self.parseEvent(event));
  });
}

CombatLogParser.prototype.readFile = function (){
  var filename = [this.log_dir, this.last_logfile].join("/")
    , startpos = this.last_logfile_readpt
    ;
    
  this.emit('debug', 'filename: ' + filename);
  this.emit('debug', 'startpos: ' + startpos);
     
  if (this.read_stream !== null){
    this.emit('error', new Error('Read stream is already open'));
  }
  else {
    this.read_stream = fs.createReadStream(filename, {encoding: 'utf8', start: startpos});
    var bytes_read = 0;
    
    var self = this;
    this.read_stream.on('open', function (){
      bytes_read = 0;
      self.emit('start read', true);
    });
    
    this.read_stream.on('error', function (err){
      self.emit('error', err);
    });
    
    this.read_stream.on('end', function (){
      self.last_logfile_readpt += bytes_read;
      self.emit('end read', bytes_read);
      self.read_stream.destroy();
      self.read_stream = null;
    });
    
    this.read_stream.on('data', function (chunk){
      bytes_read += (new Buffer(chunk)).length;
      self.chunk_buffer += chunk;
      self.drainChunks();
    });
  }
}

CombatLogParser.prototype.stop = function (){
  if (typeof this.read_stream.destroy !== "undefined"){
    this.read_stream.destroy();
  }
  this.read_stream = null;
  this.watcher.close();
  this.emit('stop', true); 
}

CombatLogParser.prototype.drainChunks = function (){
  var ind = this.chunk_buffer.indexOf("\n");
  if (ind !== -1){
    var event = this.chunk_buffer.substring(0, ind);
    this.chunk_buffer = this.chunk_buffer.substring(ind + 1, this.chunk_buffer.length);
    this.emit('parse', event);
    this.drainChunks();
  }
}

CombatLogParser.prototype.parseEvent = function (event){
  var parts = event.trim().split("]").map(function (part){
    return part.trim().substring(1);
  });
  
  var values = (parts[5] || "").split(")").map(function (val){
    var tmp = val.trim();
    if (tmp.indexOf("<") !== -1){
      return tmp.substring(1, tmp.length - 1);
    }
    else {
      return tmp;
    }
  });
  
  var dataobj = {
    time_string: parts[0]
  , event_source: parts[1]
  , event_target: parts[2]
  , ability: parts[3]
  , effect: parts[4]
  , effect_value: values[0]
  , threat: values[1]
  }
  
  return dataobj;
}

module.exports.CombatLogParser = CombatLogParser;
