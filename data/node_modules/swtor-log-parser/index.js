var fs = require('fs')
  , util = require('util')
  , events = require('events')
  , path = require('path')
  ;

function CombatLogParser(log_dir, rwind_first){
  this.log_dir = log_dir;
  this.rewind_first = rwind_first || false;
  this._reading = false;

  this.latest_file_mtime = null;
  this.latest_file = null;
  this.latest_file_position = 0;

  this.task_queue = [];
  this.chunk_buffer = "";
  this.last_task_file = null;

  var self = this;

  this.on('parse', function (logfile, event){
    self.emit('data', self.parseEvent(logfile, event));
  });
}

util.inherits(CombatLogParser, events.EventEmitter);

function iterateTasks(task, cb){
  return function next(err){
    if (err){
      self.emit('error', err);
      return;
    }

    if (queue.length > 0){
      task(next);
    }
    else {
      cb();
    }
  };
}

CombatLogParser.prototype._dirRefreshIntervalFunc = function (){
  var self = this;
  return function (){
    self.emit('debug', 'setInterval tick');
    //fs.statSync(self.log_dir);
    fs.readdir(self.log_dir, function (err, items){
      if (err){
        self.emit('error', err);
        return;
      }

      var new_latest_mtime = null;
      var new_latest_file = self.latest_file || null;
      var new_latest_position = null;

      if (self.latest_file){
        //check for updates on the latest file
        self.emit('debug', 'check latest file');
        try {
          var fd = fs.openSync(path.join(self.log_dir, new_latest_file), 'r');
          var stats = fs.fstatSync(fd);
          fs.closeSync(fd);
        } catch (err) {
          self.emit('error', err);
          return;
        }

        if (!self.latest_file_mtime || stats.mtime.getTime() > self.latest_file_mtime || stats.size > self.latest_file_position){
          self.emit('debug', 'change detected');
          self.emit('debug', stats.mtime.getTime());
          self.emit('debug', stats.size);
          new_latest_mtime = stats.mtime.getTime();
          self.readFile(self.latest_file, self.latest_file_position || 0, function (bytes_read){
            new_latest_position = bytes_read;
            self.latest_file_position = bytes_read;
            self.latest_file_mtime = stats.mtime.getTime();
            self.emit('debug', self.latest_file);
            self.emit('debug', self.latest_file_mtime);
            self.emit('debug', self.latest_file_position);
            afterLatestFile();
          });
        }
        else {
          afterLatestFile();
        }
      }
      else {
        afterLatestFile();
      }

      function afterLatestFile(){
        self.emit('debug', 'after latest file');
        //check for other files that were updated since we last read the latest file
        if (self.latest_file_mtime){
          //there was a file already open
          var queue = items.slice(0);

          function processItems(next){
            var item = queue.shift();

            try {
              var fd = fs.openSync(path.join(self.log_dir, item), 'r');
              var stats = fs.fstatSync(fd);
              fs.closeSync(fd);
            } catch (err) {
              self.emit('error', err);
              return;
            }

            var position = null;

            if (stats.isFile() && (!new_latest_mtime || stats.mtime.getTime() > new_latest_mtime)){
              //we read from the beginning of that file
              self.readFile(item, 0, function (position){
                new_latest_mtime = stats.mtime.getTime();
                new_latest_file = item;
                new_latest_position = position;
                self.emit('debug', self.latest_file);
                self.emit('debug', self.latest_file_mtime);
                self.emit('debug', self.latest_file_position);
              });
            }
            else {
              next();
            }
          }

          iterateTasks(processItems, function (){
            //set the new latest info
            self.latest_file = new_latest_file;
            self.latest_file_mtime = new_latest_mtime;
            self.latest_file_position = new_latest_position;

            self.emit('debug', self.latest_file);
            self.emit('debug', self.latest_file_mtime);
            self.emit('debug', self.latest_file_position);
          });


        }
        else {
          //no file already open. go find the newest one then read it.
          items.forEach(function (item){
            try {
              var fd = fs.openSync(path.join(self.log_dir, item), 'r');
              var stats = fs.fstatSync(fd);
              fs.closeSync(fd);
            } catch (err) {
              self.emit('error', err);
              return;
            }

            if (!new_latest_mtime || stats.mtime.getTime() > new_latest_mtime){
              new_latest_mtime = stats.mtime.getTime();
              new_latest_file = item;
              new_latest_position = (self.rewind_first ? 0 : stats.size) || 0;
            }
          });

          self.readFile(new_latest_file, new_latest_position, function (bytes_read){
            self.latest_file = new_latest_file;
            self.latest_file_mtime = new_latest_mtime;
            self.latest_file_position = bytes_read;

            self.emit('debug', self.latest_file);
            self.emit('debug', self.latest_file_mtime);
            self.emit('debug', self.latest_file_position);
          });
        }
      }
    });
  };
};

CombatLogParser.prototype.start = function (){
  setInterval(this._dirRefreshIntervalFunc(), 1000);

  this.emit('start');
};

CombatLogParser.prototype.readFile = function (filename, startpos, callback){
  var self = this;

  self.emit('debug', 'readFile called');
  self.emit('debug', filename);
  self.emit('debug', startpos);
  self.emit('debug', callback);

  if (filename){
    self.emit('debug', 'added file to task queue');
    //trying to read another file. add it to the queue
    if (typeof startpos === "function"){
      callback = startpos;
      startpos = 0;
    }

    callback = callback || function (){};

    this.task_queue.push([filename, startpos, callback]);

    if (!this._reading){
      this._reading = true;

      process.nextTick(function (){self.readFile();});
    }
  }
  else if (this._reading){
    this.emit('debug', 'reading file');
    //function called without arguments -- process queue
    var task = this.task_queue.shift()
      ;

    if (!task){
      this.emit('debug', 'task queue empty');
      this._reading = false;
      this.task_queue = [];
      return;
    }

    if (this.last_task_file !== task[0]){
      this.chunk_buffer = "";
      this.emit('debug', 'resetting chunk buffer');
    }

    var read_stream = fs.createReadStream(path.join(this.log_dir, task[0]), {start: task[1] || 0});
    var bytes_read = 0;

    read_stream.on('data', function (chunk){

      bytes_read += chunk.length;
      var parts = (self.chunk_buffer + chunk.toString('utf8')).split(/\r?\n/);
      if (parts.length === 1){
        self.chunk_buffer = parts[0];
      }
      else {
        self.chunk_buffer = parts.pop();
        parts.forEach(function (part){
          self.emit('parse', task[0], part);
        });
      }
    });

    read_stream.on('error', function (err){
      self.emit('error', err);
    });

    read_stream.on('end', function (){
      self.emit('debug', 'bytes read from ' + task[0] + ': ' + bytes_read);
      process.nextTick(function (){self.readFile();});
      task[2](bytes_read + (task[1] || 0));
    });
  }


};

CombatLogParser.prototype.stop = function (){
  clearInterval(this._dirRefreshIntervalFunc());
  this.emit('stop', true);
};

CombatLogParser.prototype.parse_regex = /^\s*\[([^\]]*)\]\s*\[([^\]]*)\]\s*\[([^\]]*)\]\s*\[([^\]]*)\]\s*\[([^\]]*)\]\s*\((.*)\)(?:\s*<([^>]*)>)?\s*$/;
CombatLogParser.prototype.effect_regex = /^\s*(.*)\s+{(.*)}:\s*(.*)\s+{(.*)}\s*$/;
CombatLogParser.prototype.effect_value_regex = /^\s*([0-9*]*)(?:\s+(.*)\s+{(.*)}(?:\(([0-9*]+)\s+(.*)\s+{(.*)}\))?)?\s*$/;
CombatLogParser.prototype.source_target_regex = /^\s*([^{]*)(?:\s+{(.*)}(?:\s*:(.*))?)?\s*$/;
CombatLogParser.prototype.ability_regex = /^\s*(.*)\s+{(.*)}\s*$/;
CombatLogParser.prototype.filename_regex = /^combat_(\d{4})-(\d{2})-(\d{2})_.*$/;

CombatLogParser.prototype.parseEvent = function (logfile, event){

  this.emit('debug', logfile);
  this.emit('debug', event);
  //var parts = (this._read_buffer + event).match(this.parse_regex);
  var parts = (event).match(this.parse_regex);
  var date_parts = (logfile || "").match(this.filename_regex);

  if (parts){
    var effect_parts = parts[5].match(this.effect_regex)
      , effect_details = {
          type: effect_parts[1]
        , type_id: effect_parts[2]
        , name: effect_parts[3]
        , name_id: effect_parts[4]
        }
      , effect_value_parts = parts[6].match(this.effect_value_regex)
      , effect_value_details = {
          amt: 0
        , is_crit: false
        , type: 'unknown'
        , type_id: null
        , absorb_amt: 0
        }
      , source_parts = parts[2].match(this.source_target_regex)
      , source_details = {
          name: ((source_parts[1] || "").substring(0,1) === "@") ? source_parts[1].substring(1) : source_parts[1]
        , is_player: (source_parts[1] || "").substring(0,1) === "@"
        , is_companion: ((source_parts[1] || "").substring(0,1) === "@") && source_parts[2]
        , name_id: source_parts[2]
        , unique_id: source_parts[3]
        }
      , target_parts = parts[3].match(this.source_target_regex)
      , target_details = {
          name: ((target_parts[1] || "").substring(0,1) === "@") ? target_parts[1].substring(1) : target_parts[1]
        , is_player: (target_parts[1] || "").substring(0,1) === "@"
        , name_id: target_parts[2]
        , unique_id: target_parts[3]
        }
      , ability_parts = parts[4].match(this.ability_regex)
      , ability_details = {
          name: null
        , name_id: null
        }
      ;

    if (effect_value_parts){
      //this.emit('debug', effect_value_parts[1].substring(effect_value_parts[1].length - 1));

      effect_value_details = {
        amt: ((effect_value_parts[1] || "").substring(effect_value_parts[1].length - 1) === "*") ? parseInt((effect_value_parts[1] || "").substring(0, (effect_value_parts[1] || "").length - 1) || 0) : parseInt(effect_value_parts[1] || 0)
      , is_crit: ((effect_value_parts[1] || "").substring(effect_value_parts[1].length - 1) === "*")
      , type: effect_value_parts[2] || ""
      , absorb_amt: (effect_value_parts[4] && effect_value_parts[5] === "absorbed") ? parseInt(effect_value_parts[4]) : 0
      };
    }

    if (ability_parts){
      ability_details = {
        name: ability_parts[1]
      , name_id: ability_parts[2]
      }
    }

    var dataobj = {
      timestring: parts[1]
    , timestamp: null
    , event_source: source_details
    , event_target: target_details
    , ability: ability_details
    , effect: effect_details
    , effect_value: effect_value_details
    , threat: parseInt(parts[7] || 0)
    };

    if (date_parts){
      var tzoffset = ((new Date(date_parts.slice(1).join("-"))).getTimezoneOffset() * 100 / 60);
      var tzochar = "-";
      if (tzoffset < 0){
        tzochar = "+";
        tzoffset = tzoffset * -1;
      }

      tzoffset = tzoffset + '';

      if (tzoffset.length < 4){
        tzoffset = "0" + tzoffset;
      }

      if (tzoffset.substring(tzoffset.length - 2) === "50"){
        tzoffset = tzoffset.substring(0,2) + "30";
      }

      dataobj.timestring = date_parts.slice(1).join("-") + "T" + dataobj.timestring + tzochar + tzoffset;
      dataobj.timestamp = (new Date(dataobj.timestring)).getTime();
    }

    return dataobj;
  }
  else {
    this.emit('debug', 'parser error: ' + (this._read_buffer + event));
    //this._read_buffer += event;
    return null;
  }
};

module.exports.CombatLogParser = CombatLogParser;
