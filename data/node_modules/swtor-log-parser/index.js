var fs = require('fs')
  , util = require('util')
  , events = require('events')
  , tailf = require('tailf')
  , path = require('path')
  ;
  
function CombatLogParser(log_dir){
  var self = this;
  this.log_dir = log_dir;
  this.watcher = null;
  this.read_stream = null;
  this.read_stream_file = null;
  this._reading = false;
  this._read_buffer = "";
  
  this.task_queue = [];
  
  this.emit('debug', 'test');
}

util.inherits(CombatLogParser, events.EventEmitter);

CombatLogParser.prototype.start = function (){
  if (this.watcher !== null){
    this.emit('error', new Error('Watcher is already running'));
  }
  else {
    var self = this;
    this.watcher = fs.watch(this.log_dir, {persistent: true}, function (event, filename){
      if (event === "rename"){
        self.emit('debug', 'rename event: ' + filename);
        
        if (filename.substring(0,1) === "."){
          self.emit('debug', 'hidden file. ignoring.');
        }
        else if (!fs.exists(path.join(self.log_dir, filename))) {
          self.emit('debug', 'file removed.');
          self.emit('debug', 'checking against read_stream_file: ' + path.join(self.log_dir, filename) + " vs. " + self.read_stream_file);
          if (path.join(self.log_dir, filename) === self.read_stream_file){
            self.read_stream.stop();
            self._reading = false;
            self.read_stream_file = null;
            
            self.emit('debug', 'closing read stream');
          }
          else {
            self.emit('debug', 'ignoring');
          }
        }
        else {
          self.readFile(filename, true); 
        }      
      }
      else if (event === "change"){
        self.emit('debug', 'change event: ' + filename);
        if (filename.substring(0,1) === "."){
          self.emit('debug', 'hidden file. ignoring.');
        }
        else {
          self.readFile(filename);
        }
      }
      else {
        self.emit('error', new Error("Unknown event type emitted from the directory watcher"));
      }
    });
    
    self.emit('start');
  }
  
  this.on('parse', function (event){
    self.emit('data', self.parseEvent(event));
  });
}

CombatLogParser.prototype.readFile = function (filename, force){
  var filename = path.join(this.log_dir, filename)
    , self = this
    ;
    
  this.emit('debug', "readFile " + filename + ", " + force);
    
  if (this._reading && force){
    this.emit('debug', 'read stream reading. forcing');
    this.read_stream.stop();
    this._reading = false;
    this.read_stream_file = null;
  }
  
  if (!this._reading){
    this.emit('debug', 'creating read stream');
    this.read_stream = new tailf.blockTailf(filename, /\n/);
    this.read_stream_file = filename;
    this.emit('debug', 'setting read_stream_file: ' + filename);
    
    this.read_stream.on('data', function (data){
      data = data.toString('utf8');
      //self.emit('debug', 'data read: ' + data);
      self.emit('parse', data);
    });
    
    this.read_stream.on('error', function (err){
      self.emit('debug', 'read stream error: ' + err);
      self.read_stream.stop();
      self._reading = false;
      self.read_stream_file = null;
    });
    
    this.read_stream.start(true);
  }
}

CombatLogParser.prototype.stop = function (){
  if (this.read_stream !== null){
    this.read_stream.stop();
    this._reading = false;
    this.read_stream_file = null;
  }
  this.watcher.close();
  this.emit('stop', true); 
};

CombatLogParser.prototype.parse_regex = /^\s*\[([^\]]*)\]\s*\[([^\]]*)\]\s*\[([^\]]*)\]\s*\[([^\]]*)\]\s*\[([^\]]*)\]\s*\((.*)\)(?:\s*<([^>]*)>)?\s*$/;
CombatLogParser.prototype.effect_regex = /^\s*(.*)\s+{(.*)}:\s*(.*)\s+{(.*)}\s*$/;
CombatLogParser.prototype.effect_value_regex = /^\s*([0-9*]*)(?:\s+(.*)\s+{(.*)}(?:\(([0-9*]+)\s+(.*)\s+{(.*)}\))?)?\s*$/;
CombatLogParser.prototype.source_target_regex = /^\s*([^{]*)(?:\s+{(.*)}(?:\s*:(.*))?)?\s*$/;
CombatLogParser.prototype.ability_regex = /^\s*(.*)\s+{(.*)}\s*$/;

CombatLogParser.prototype.parseEvent = function (event){

  //var parts = (this._read_buffer + event).match(this.parse_regex);
  var parts = (event).match(this.parse_regex);
  
  if (parts){
    var effect_parts = parts[5].match(this.effect_regex)
      , effect_details = {
          type: effect_parts[1]
        , type_id: effect_parts[2]
        , name: effect_parts[3]
        , name_id: effect_parts[4]
        }
      , effect_value_parts = parts[6].match(this.effect_value_regex)
      , effect_value_details = {
          amt: 0
        , is_crit: false
        , type: 'unknown'
        , type_id: null
        , absorb_amt: 0  
        }
      , source_parts = parts[2].match(this.source_target_regex)
      , source_details = {
          name: ((source_parts[1] || "").substring(0,1) === "@") ? source_parts[1].substring(1) : source_parts[1]
        , is_player: (source_parts[1] || "").substring(0,1) === "@"
        , name_id: source_parts[2]
        , unique_id: source_parts[3]
        }
      , target_parts = parts[3].match(this.source_target_regex)
      , target_details = {
          name: ((target_parts[1] || "").substring(0,1) === "@") ? target_parts[1].substring(1) : target_parts[1]
        , is_player: (target_parts[1] || "").substring(0,1) === "@"
        , name_id: target_parts[2]
        , unique_id: target_parts[3]
        }
      , ability_parts = parts[4].match(this.ability_regex)
      , ability_details = {
          name: null
        , name_id: null
        }
      ;
      
    if (effect_value_parts){
      //this.emit('debug', effect_value_parts[1].substring(effect_value_parts[1].length - 1));
    
      effect_value_details = {
        amt: ((effect_value_parts[1] || "").substring(effect_value_parts[1].length - 1) === "*") ? parseInt((effect_value_parts[1] || "").substring(0, (effect_value_parts[1] || "").length - 1) || 0) : parseInt(effect_value_parts[1] || 0)
      , is_crit: ((effect_value_parts[1] || "").substring(effect_value_parts[1].length - 1) === "*")
      , type: effect_value_parts[2] || ""
      , absorb_amt: (effect_value_parts[4] && effect_value_parts[5] === "absorbed") ? parseInt(effect_value_parts[4]) : 0
      };
    }
    
    if (ability_parts){
      ability_details = {
        name: ability_parts[1]
      , name_id: ability_parts[2]
      }
    }
      
    var dataobj = {
      time_string: parts[1]
    , event_source: source_details
    , event_target: target_details
    , ability: ability_details
    , effect: effect_details
    , effect_value: effect_value_details
    , threat: parseInt(parts[7] || 0)
    };
    
    return dataobj;
  }
  else {
    this.emit('debug', 'parser error: ' + (this._read_buffer + event));
    //this._read_buffer += event;
  }
};

module.exports.CombatLogParser = CombatLogParser;
